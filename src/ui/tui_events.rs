use crate::ui::tui_state::UiState;
use crossterm::event::{Event, KeyCode, KeyModifiers};
use fuzzy_matcher::{FuzzyMatcher, skim::SkimMatcherV2};
use std::collections::HashSet;
use std::path::PathBuf;

/// Represents UI messages generated by key events
#[derive(Debug, PartialEq)]
pub enum UiMsg {
    Quit,
    SelectNext,
    SelectPrev,
    ToggleCurrent,
    ToggleAll,
    UnselectAll,
    InvertSelection,
    SelectOne,
    ToggleExtensionMode,
    Submit,
    // Add more variants as needed
}

// Helper to apply extension-based filtering of items
fn apply_extension_items(
    chosen_exts: &HashSet<String>,
    items: &mut [(PathBuf, bool)],
    union_mode: bool,
    all_known_exts: &HashSet<String>,
) {
    for (p, checked) in items.iter_mut() {
        if let Some(pext) = p.extension().map(|e| format!(".{}", e.to_string_lossy())) {
            if all_known_exts.contains(&pext) {
                if union_mode {
                    if chosen_exts.contains(&pext) {
                        *checked = true;
                    }
                } else {
                    *checked = chosen_exts.contains(&pext);
                }
            }
        }
    }
}

/// Handle a crossterm Event, update state, and return an optional UiMsg
pub fn handle_event(
    state: &mut UiState,
    event: Event,
) -> Option<UiMsg> {
    if let Event::Key(key) = event {
        let code = key.code;
        let mods = key.modifiers;

        // Ctrl+E: enter/exit extension-filter mode
        if mods.contains(KeyModifiers::CONTROL) && code == KeyCode::Char('e') {
            if !state.extension_mode {
                // entering extension mode: save search, clear for extension
                state.saved_search_input = state.search_input.clone();
                state.search_input.clear();
                state.extension_mode = true;
                if state.reset_ext_on_toggle {
                    state
                        .extension_items
                        .iter_mut()
                        .for_each(|(_, c)| *c = false);
                    state.extension_search.clear();
                }
            } else {
                // exiting: restore
                state.search_input = state.saved_search_input.clone();
                state.extension_mode = false;
            }
            return Some(UiMsg::ToggleExtensionMode);
        }

        // If in extension-filter mode
        if state.extension_mode {
            // build filtered extension indices
            let filtered_ext: Vec<usize> = if state.extension_search.is_empty() {
                (0..state.extension_items.len()).collect()
            } else {
                let matcher = SkimMatcherV2::default();
                let mut vec = Vec::new();
                for (i, (ext, _)) in state.extension_items.iter().enumerate() {
                    if let Some(score) = matcher.fuzzy_match(ext, &state.extension_search) {
                        vec.push((i, score));
                    }
                }
                vec.sort_by_key(|&(_, s)| -s);
                vec.into_iter().map(|(i, _)| i).collect()
            };
            match code {
                KeyCode::Up => state.ext_selected_idx = state.ext_selected_idx.saturating_sub(1),
                KeyCode::Down => {
                    if state.ext_selected_idx + 1 < filtered_ext.len() {
                        state.ext_selected_idx += 1;
                    }
                }
                KeyCode::Backspace => {
                    state.extension_search.pop();
                }
                // Space toggles the current extension
                KeyCode::Char(' ') => {
                    if let Some(&orig) = filtered_ext.get(state.ext_selected_idx) {
                        state.extension_items[orig].1 = !state.extension_items[orig].1;
                    }
                }
                // Other chars update the extension search
                KeyCode::Char(c) => {
                    state.extension_search.push(c);
                }
                KeyCode::Enter => {
                    let chosen_exts: HashSet<String> = state
                        .extension_items
                        .iter()
                        .filter_map(|(e, c)| if *c { Some(e.clone()) } else { None })
                        .collect();
                    let all_known: HashSet<String> = state
                        .extension_items
                        .iter()
                        .map(|(e, _)| e.clone())
                        .collect();
                    apply_extension_items(&chosen_exts, &mut state.items, false, &all_known);
                    state.extension_mode = false;
                    state.search_input = state.saved_search_input.clone();
                }
                _ => {}
            }
            return None;
        }

        // build filtered file indices for fuzzy search
        let filtered_files: Vec<usize> = if state.search_input.is_empty() {
            (0..state.items.len()).collect()
        } else {
            let matcher = SkimMatcherV2::default();
            let mut vec = Vec::new();
            for (i, (p, _)) in state.items.iter().enumerate() {
                if let Some(score) = matcher.fuzzy_match(&p.to_string_lossy(), &state.search_input)
                {
                    vec.push((i, score));
                }
            }
            vec.sort_by_key(|&(_, s)| -s);
            vec.into_iter().map(|(i, _)| i).collect()
        };

        // Ctrl-based bulk commands on filtered files
        if mods.contains(KeyModifiers::CONTROL) {
            match code {
                KeyCode::Char('a') => {
                    let all_sel = filtered_files.iter().all(|&i| state.items[i].1);
                    filtered_files
                        .iter()
                        .for_each(|&i| state.items[i].1 = !all_sel);
                    return Some(UiMsg::ToggleAll);
                }
                KeyCode::Char('u') => {
                    filtered_files
                        .iter()
                        .for_each(|&i| state.items[i].1 = false);
                    return Some(UiMsg::UnselectAll);
                }
                KeyCode::Char('i') => {
                    filtered_files
                        .iter()
                        .for_each(|&i| state.items[i].1 = !state.items[i].1);
                    return Some(UiMsg::InvertSelection);
                }
                KeyCode::Char('o') => {
                    if let Some(&orig) = filtered_files.get(state.selected_idx) {
                        state.items.iter_mut().for_each(|(_, c)| *c = false);
                        state.items[orig].1 = true;
                    }
                    return Some(UiMsg::SelectOne);
                }
                KeyCode::Char('q') => return Some(UiMsg::Quit),
                _ => {}
            }
        }

        // typing for fuzzy search (exclude space and 'q' which are handled separately)
        if mods.is_empty() {
            match code {
                KeyCode::Backspace => {
                    state.search_input.pop();
                    return None;
                }
                // push normal chars into search, but skip space and 'q'
                KeyCode::Char(c) if c != ' ' && c != 'q' => {
                    state.search_input.push(c);
                    return None;
                }
                _ => {}
            }
        }

        // navigation and toggles in file mode
        match code {
            KeyCode::Char('q') | KeyCode::Esc => return Some(UiMsg::Quit),
            KeyCode::Down => {
                if state.selected_idx + 1 < filtered_files.len() {
                    state.selected_idx += 1;
                }
                return Some(UiMsg::SelectNext);
            }
            KeyCode::Up => {
                state.selected_idx = state.selected_idx.saturating_sub(1);
                return Some(UiMsg::SelectPrev);
            }
            KeyCode::Char(' ') => {
                if let Some(&orig) = filtered_files.get(state.selected_idx) {
                    state.items[orig].1 = !state.items[orig].1;
                }
                return Some(UiMsg::ToggleCurrent);
            }
            KeyCode::Enter => return Some(UiMsg::Submit),
            _ => {}
        }
    }
    None
}

// Unit tests for handle_event
#[cfg(test)]
mod tests {
    use super::*;
    use crossterm::event::{Event, KeyCode, KeyEvent, KeyModifiers};
    use std::path::PathBuf;

    fn make_state() -> UiState {
        let paths = vec![PathBuf::from("a"), PathBuf::from("b"), PathBuf::from("c")];
        UiState::new(paths, &[])
    }

    #[test]
    fn test_select_next() {
        let mut state = make_state();
        let evt = Event::Key(KeyEvent::new(KeyCode::Down, KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::SelectNext));
        assert_eq!(state.selected_idx, 1);
    }

    #[test]
    fn test_select_prev() {
        let mut state = make_state();
        state.selected_idx = 1;
        let evt = Event::Key(KeyEvent::new(KeyCode::Up, KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::SelectPrev));
        assert_eq!(state.selected_idx, 0);
    }

    #[test]
    fn test_toggle_current() {
        let mut state = make_state();
        assert!(!state.items[0].1);
        let evt = Event::Key(KeyEvent::new(KeyCode::Char(' '), KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::ToggleCurrent));
        assert!(state.items[0].1);
    }

    #[test]
    fn test_submit() {
        let mut state = make_state();
        let evt = Event::Key(KeyEvent::new(KeyCode::Enter, KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::Submit));
    }

    #[test]
    fn test_quit() {
        let mut state = make_state();
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::Quit));
    }

    #[test]
    fn test_toggle_all() {
        let mut state = make_state();
        // first ctrl+a selects all
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('a'), KeyModifiers::CONTROL));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::ToggleAll));
        assert!(state.items.iter().all(|(_, checked)| *checked));
        // second ctrl+a unselects all
        let evt2 = Event::Key(KeyEvent::new(KeyCode::Char('a'), KeyModifiers::CONTROL));
        let msg2 = handle_event(&mut state, evt2);
        assert_eq!(msg2, Some(UiMsg::ToggleAll));
        assert!(state.items.iter().all(|(_, checked)| !*checked));
    }

    #[test]
    fn test_unselect_all() {
        let mut state = make_state();
        // preload some selected
        state.items[0].1 = true;
        state.items[2].1 = true;
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('u'), KeyModifiers::CONTROL));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::UnselectAll));
        assert!(state.items.iter().all(|(_, checked)| !*checked));
    }

    #[test]
    fn test_invert_selection() {
        let mut state = make_state();
        // first only index 1 selected
        state.items[1].1 = true;
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('i'), KeyModifiers::CONTROL));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::InvertSelection));
        assert_eq!(state.items.iter().filter(|(_, c)| *c).count(), 2);
    }

    #[test]
    fn test_select_one() {
        let mut state = make_state();
        state.selected_idx = 2;
        // preload all selected
        for item in &mut state.items {
            item.1 = true;
        }
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('o'), KeyModifiers::CONTROL));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::SelectOne));
        assert_eq!(state.items.iter().filter(|(_, c)| *c).count(), 1);
        assert!(state.items[2].1);
    }

    #[test]
    fn test_toggle_extension_mode() {
        let mut state = make_state();
        state.extension_mode = false;
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('e'), KeyModifiers::CONTROL));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::ToggleExtensionMode));
        assert!(state.extension_mode);
        // toggle off
        let evt2 = Event::Key(KeyEvent::new(KeyCode::Char('e'), KeyModifiers::CONTROL));
        let msg2 = handle_event(&mut state, evt2);
        assert_eq!(msg2, Some(UiMsg::ToggleExtensionMode));
        assert!(!state.extension_mode);
    }
}
