use crate::ui::tui_state::UiState;
use crossterm::event::{Event, KeyCode, KeyModifiers};

/// Represents UI messages generated by key events
#[derive(Debug, PartialEq)]
pub enum UiMsg {
    Quit,
    SelectNext,
    SelectPrev,
    ToggleCurrent,
    ToggleAll,
    UnselectAll,
    InvertSelection,
    SelectOne,
    ToggleExtensionMode,
    Submit,
    // Add more variants as needed
}

/// Handle a crossterm Event, update state, and return an optional UiMsg
pub fn handle_event(
    state: &mut UiState,
    event: Event,
) -> Option<UiMsg> {
    if let Event::Key(key_event) = event {
        // Ctrl+A toggles select/unselect all items
        if key_event.modifiers.contains(KeyModifiers::CONTROL)
            && key_event.code == KeyCode::Char('a')
        {
            let all_selected = state.items.iter().all(|(_, checked)| *checked);
            for item in &mut state.items {
                item.1 = !all_selected;
            }
            return Some(UiMsg::ToggleAll);
        }
        // Ctrl+U unselects all
        if key_event.modifiers.contains(KeyModifiers::CONTROL)
            && key_event.code == KeyCode::Char('u')
        {
            for item in &mut state.items {
                item.1 = false;
            }
            return Some(UiMsg::UnselectAll);
        }
        // Ctrl+I inverts selection
        if key_event.modifiers.contains(KeyModifiers::CONTROL)
            && key_event.code == KeyCode::Char('i')
        {
            for item in &mut state.items {
                item.1 = !item.1;
            }
            return Some(UiMsg::InvertSelection);
        }
        // Ctrl+O selects only the focused item
        if key_event.modifiers.contains(KeyModifiers::CONTROL)
            && key_event.code == KeyCode::Char('o')
        {
            let idx = state.selected_idx;
            for item in &mut state.items {
                item.1 = false;
            }
            state.items[idx].1 = true;
            return Some(UiMsg::SelectOne);
        }
        // Ctrl+E toggles the extension filter panel
        if key_event.modifiers.contains(KeyModifiers::CONTROL)
            && key_event.code == KeyCode::Char('e')
        {
            state.extension_mode = !state.extension_mode;
            return Some(UiMsg::ToggleExtensionMode);
        }
        match key_event.code {
            KeyCode::Char('q') | KeyCode::Esc => return Some(UiMsg::Quit),
            KeyCode::Char('j') | KeyCode::Down => {
                if state.selected_idx + 1 < state.items.len() {
                    state.selected_idx += 1;
                }
                return Some(UiMsg::SelectNext);
            }
            KeyCode::Char('k') | KeyCode::Up => {
                if state.selected_idx > 0 {
                    state.selected_idx -= 1;
                }
                return Some(UiMsg::SelectPrev);
            }
            KeyCode::Char(' ') => {
                // Toggle the checked state of the current item
                state.items[state.selected_idx].1 = !state.items[state.selected_idx].1;
                return Some(UiMsg::ToggleCurrent);
            }
            KeyCode::Enter => return Some(UiMsg::Submit),
            _ => {}
        }
    }
    None
}

// Unit tests for handle_event
#[cfg(test)]
mod tests {
    use super::*;
    use crossterm::event::{Event, KeyCode, KeyEvent, KeyModifiers};
    use std::path::PathBuf;

    fn make_state() -> UiState {
        let paths = vec![PathBuf::from("a"), PathBuf::from("b"), PathBuf::from("c")];
        UiState::new(paths, &[])
    }

    #[test]
    fn test_select_next() {
        let mut state = make_state();
        let evt = Event::Key(KeyEvent::new(KeyCode::Down, KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::SelectNext));
        assert_eq!(state.selected_idx, 1);
    }

    #[test]
    fn test_select_prev() {
        let mut state = make_state();
        state.selected_idx = 1;
        let evt = Event::Key(KeyEvent::new(KeyCode::Up, KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::SelectPrev));
        assert_eq!(state.selected_idx, 0);
    }

    #[test]
    fn test_toggle_current() {
        let mut state = make_state();
        assert!(!state.items[0].1);
        let evt = Event::Key(KeyEvent::new(KeyCode::Char(' '), KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::ToggleCurrent));
        assert!(state.items[0].1);
    }

    #[test]
    fn test_submit() {
        let mut state = make_state();
        let evt = Event::Key(KeyEvent::new(KeyCode::Enter, KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::Submit));
    }

    #[test]
    fn test_quit() {
        let mut state = make_state();
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::Quit));
    }

    #[test]
    fn test_toggle_all() {
        let mut state = make_state();
        // first ctrl+a selects all
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('a'), KeyModifiers::CONTROL));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::ToggleAll));
        assert!(state.items.iter().all(|(_, checked)| *checked));
        // second ctrl+a unselects all
        let evt2 = Event::Key(KeyEvent::new(KeyCode::Char('a'), KeyModifiers::CONTROL));
        let msg2 = handle_event(&mut state, evt2);
        assert_eq!(msg2, Some(UiMsg::ToggleAll));
        assert!(state.items.iter().all(|(_, checked)| !*checked));
    }

    #[test]
    fn test_unselect_all() {
        let mut state = make_state();
        // preload some selected
        state.items[0].1 = true;
        state.items[2].1 = true;
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('u'), KeyModifiers::CONTROL));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::UnselectAll));
        assert!(state.items.iter().all(|(_, checked)| !*checked));
    }

    #[test]
    fn test_invert_selection() {
        let mut state = make_state();
        // first only index 1 selected
        state.items[1].1 = true;
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('i'), KeyModifiers::CONTROL));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::InvertSelection));
        assert_eq!(state.items.iter().filter(|(_, c)| *c).count(), 2);
    }

    #[test]
    fn test_select_one() {
        let mut state = make_state();
        state.selected_idx = 2;
        // preload all selected
        for item in &mut state.items {
            item.1 = true;
        }
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('o'), KeyModifiers::CONTROL));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::SelectOne));
        assert_eq!(state.items.iter().filter(|(_, c)| *c).count(), 1);
        assert!(state.items[2].1);
    }

    #[test]
    fn test_toggle_extension_mode() {
        let mut state = make_state();
        state.extension_mode = false;
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('e'), KeyModifiers::CONTROL));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::ToggleExtensionMode));
        assert!(state.extension_mode);
        // toggle off
        let evt2 = Event::Key(KeyEvent::new(KeyCode::Char('e'), KeyModifiers::CONTROL));
        let msg2 = handle_event(&mut state, evt2);
        assert_eq!(msg2, Some(UiMsg::ToggleExtensionMode));
        assert!(!state.extension_mode);
    }
}
