use crate::ui::tui_state::UiState;
use crossterm::event::{Event, KeyCode};

/// Represents UI messages generated by key events
#[derive(Debug, PartialEq)]
pub enum UiMsg {
    Quit,
    SelectNext,
    SelectPrev,
    ToggleCurrent,
    Submit,
    // Add more variants as needed
}

/// Handle a crossterm Event, update state, and return an optional UiMsg
pub fn handle_event(
    state: &mut UiState,
    event: Event,
) -> Option<UiMsg> {
    if let Event::Key(key_event) = event {
        match key_event.code {
            KeyCode::Char('q') | KeyCode::Esc => return Some(UiMsg::Quit),
            KeyCode::Char('j') | KeyCode::Down => {
                if state.selected_idx + 1 < state.items.len() {
                    state.selected_idx += 1;
                }
                return Some(UiMsg::SelectNext);
            }
            KeyCode::Char('k') | KeyCode::Up => {
                if state.selected_idx > 0 {
                    state.selected_idx -= 1;
                }
                return Some(UiMsg::SelectPrev);
            }
            KeyCode::Char(' ') => {
                // Toggle the checked state of the current item
                state.items[state.selected_idx].1 = !state.items[state.selected_idx].1;
                return Some(UiMsg::ToggleCurrent);
            }
            KeyCode::Enter => return Some(UiMsg::Submit),
            _ => {}
        }
    }
    None
}

// Unit tests for handle_event
#[cfg(test)]
mod tests {
    use super::*;
    use crossterm::event::{Event, KeyCode, KeyEvent, KeyModifiers};
    use std::path::PathBuf;

    fn make_state() -> UiState {
        let paths = vec![PathBuf::from("a"), PathBuf::from("b"), PathBuf::from("c")];
        UiState::new(paths, &[])
    }

    #[test]
    fn test_select_next() {
        let mut state = make_state();
        let evt = Event::Key(KeyEvent::new(KeyCode::Down, KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::SelectNext));
        assert_eq!(state.selected_idx, 1);
    }

    #[test]
    fn test_select_prev() {
        let mut state = make_state();
        state.selected_idx = 1;
        let evt = Event::Key(KeyEvent::new(KeyCode::Up, KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::SelectPrev));
        assert_eq!(state.selected_idx, 0);
    }

    #[test]
    fn test_toggle_current() {
        let mut state = make_state();
        assert!(!state.items[0].1);
        let evt = Event::Key(KeyEvent::new(KeyCode::Char(' '), KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::ToggleCurrent));
        assert!(state.items[0].1);
    }

    #[test]
    fn test_submit() {
        let mut state = make_state();
        let evt = Event::Key(KeyEvent::new(KeyCode::Enter, KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::Submit));
    }

    #[test]
    fn test_quit() {
        let mut state = make_state();
        let evt = Event::Key(KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE));
        let msg = handle_event(&mut state, evt);
        assert_eq!(msg, Some(UiMsg::Quit));
    }
}
